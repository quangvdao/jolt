//! Unified prover for the recursion SNARK protocol
//!
//! This module provides a high-level prover that orchestrates:
//! - Stage 1: Packed GT exp sumcheck
//! - Stage 2: Batched constraint sumchecks (shift + claim reduction + remaining constraints)
//! - Stage 3: Virtualization direct evaluation
//! - Stage 4: Jagged transform sumcheck
//! - Stage 5: Jagged assist sumcheck
//!
//! The prover returns a proof and opening accumulator for PCS verification.

use crate::{
    field::JoltField,
    poly::{
        commitment::{
            commitment_scheme::{CommitmentScheme, RecursionExt},
            dory::{wrappers::ArkDoryProof, ArkworksVerifierSetup, DoryCommitmentScheme},
        },
        dense_mlpoly::DensePolynomial,
        multilinear_polynomial::MultilinearPolynomial,
        opening_proof::{OpeningAccumulator, Openings, ProverOpeningAccumulator, SumcheckId},
    },
    transcripts::Transcript,
    zkvm::{
        recursion::witness::{DoryRecursionWitness, G1ScalarMulWitness},
        witness::{CommittedPolynomial, VirtualPolynomial},
    },
};
use ark_bn254::{Fq, Fr};
use ark_ff::{One, Zero};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use dory::backends::arkworks::ArkGT;
use std::collections::HashMap;

use crate::zkvm::recursion::DoryMatrixBuilder;
use dory::backends::arkworks::BN254;
use dory::recursion::ast::AstGraph;

#[cfg(feature = "experimental-pairing-recursion")]
use super::stage1::multi_miller_loop::{MultiMillerLoopParams, MultiMillerLoopProver};
use super::{
    constraints_sys::{ConstraintSystem, ConstraintType},
    stage1::gt_exp::{PackedGtExpParams, PackedGtExpProver, PackedGtExpPublicInputs},
    stage2::{
        gt_mul::{GtMulParams, GtMulProver, GtMulProverSpec},
        packed_gt_exp_reduction::{PackedGtExpClaimReductionParams, PackedGtExpClaimReductionProver},
        shift_rho::{ShiftRhoParams, ShiftRhoProver},
        shift_scalar_mul::{g1_shift_params, g2_shift_params, ShiftG1ScalarMulProver, ShiftG2ScalarMulProver},
    },
    stage3::virtualization::{
        extract_virtual_claims_from_accumulator, DirectEvaluationParams, DirectEvaluationProver,
    },
    stage4::jagged::JaggedSumcheckProver,
    stage5::jagged_assist::{JaggedAssistProof, JaggedAssistProver},
};
use crate::subprotocols::{sumcheck::BatchedSumcheck, sumcheck_prover::SumcheckInstanceProver};

/// Proof generated by the recursion SNARK
#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct RecursionProof<F: JoltField, T: Transcript, PCS: CommitmentScheme<Field = F>> {
    /// Stage 1: Packed GT exp sumcheck proof
    pub stage1_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// Stage 2: Batched constraint sumchecks proof.
    ///
    /// Includes:
    /// - packed-GT-exp internal consistency (shift rho)
    /// - packed-GT-exp claim reduction to a shared `r_x`
    /// - all other constraint families (GT mul, G1/G2 scalar mul, G1/G2 add, ...)
    pub stage2_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// Stage 3: Direct evaluation result \(M(r_s, r_x)\).
    pub stage3_m_eval: F,
    /// Stage 4: Jagged transform sumcheck proof.
    pub stage4_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// Stage 5: Jagged assist proof (batch MLE verification).
    pub stage5_proof: JaggedAssistProof<F, T>,
    /// PCS opening proof for the constraint matrix
    pub opening_proof: PCS::Proof,
    /// Gamma value used for batching constraints
    pub gamma: F,
    /// Delta value used for batching within constraints
    pub delta: F,
    /// Opening claims for virtual polynomials
    pub opening_claims: Openings<F>,
    /// Dense polynomial commitment after jagged transform
    pub dense_commitment: PCS::Commitment,
}

/// Unified prover for the recursion SNARK
#[derive(Clone)]
pub struct RecursionProver<F: JoltField = Fq> {
    /// The constraint system containing all constraints and witness data
    pub constraint_system: ConstraintSystem,
    /// Gamma value for batching across constraints
    pub gamma: F,
    /// Delta value for batching within constraints
    pub delta: F,
    /// AST graph for wiring constraints (optional, only present when using AST-enabled mode)
    pub ast: Option<AstGraph<BN254>>,
}

impl RecursionProver<Fq> {
    /// Create a new recursion prover from pre-generated witnesses
    pub fn new_from_witnesses(
        witness_collection: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<crate::zkvm::recursion::witness::GTCombineWitness>,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        tracing::debug!(
            "Creating RecursionProver from witnesses: GT exp count = {}, GT mul count = {}",
            witness_collection.gt_exp.len(),
            witness_collection.gt_mul.len()
        );

        // Convert witness collection to DoryRecursionWitness
        let recursion_witness =
            Self::witnesses_to_dory_recursion(witness_collection, combine_witness.clone())?;

        // Build constraint system from witness collection using DoryMatrixBuilder
        let build_cs_span = tracing::info_span!("build_constraint_system").entered();
        let constraint_system = Self::build_constraint_system(
            witness_collection,
            recursion_witness.combine_witness.as_ref(),
            recursion_witness.gt_exp_witness.g_poly.clone(),
        )?;
        drop(build_cs_span);

        Ok(Self {
            constraint_system,
            gamma,
            delta,
            ast: None,
        })
    }

    /// Create a new recursion prover by generating witnesses from a Dory proof
    #[allow(clippy::too_many_arguments)]
    pub fn new_from_dory_proof<T: Transcript>(
        dory_proof: &ArkDoryProof,
        verifier_setup: &ArkworksVerifierSetup,
        transcript: &mut T,
        point: &[<Fr as JoltField>::Challenge],
        evaluation: &Fr,
        commitment: &ArkGT,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        // Use Dory's witness_gen to generate witnesses
        let (witness_collection, _hints) = DoryCommitmentScheme::witness_gen(
            dory_proof,
            verifier_setup,
            transcript,
            point,
            evaluation,
            commitment,
        )?;

        // Delegate to new_from_witnesses (no combine_witness from direct Dory proof)
        Self::new_from_witnesses(&witness_collection, None, gamma, delta)
    }

    /// Create a new recursion prover with AST tracing enabled.
    ///
    /// This captures the full computation DAG, enabling:
    /// - Deterministic constraint ordering (by topological sort of AST nodes)
    /// - Wiring constraint derivation (from AST edges)
    /// - Boundary constraint identification (from AST roots and leaves)
    #[allow(clippy::too_many_arguments)]
    pub fn new_from_dory_proof_with_ast<T: Transcript>(
        dory_proof: &ArkDoryProof,
        verifier_setup: &ArkworksVerifierSetup,
        transcript: &mut T,
        point: &[<Fr as JoltField>::Challenge],
        evaluation: &Fr,
        commitment: &ArkGT,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        use crate::poly::commitment::dory::recursion::witness_gen_with_ast;

        // Use AST-enabled witness generation
        let witness_with_ast = witness_gen_with_ast(
            dory_proof,
            verifier_setup,
            transcript,
            point,
            evaluation,
            commitment,
        )?;

        // Convert witness collection to DoryRecursionWitness
        let recursion_witness =
            Self::witnesses_to_dory_recursion(&witness_with_ast.witnesses, None)?;

        // Build constraint system from witness collection
        let build_cs_span = tracing::info_span!("build_constraint_system_with_ast").entered();
        let constraint_system = Self::build_constraint_system(
            &witness_with_ast.witnesses,
            recursion_witness.combine_witness.as_ref(),
            recursion_witness.gt_exp_witness.g_poly.clone(),
        )?;
        drop(build_cs_span);

        Ok(Self {
            constraint_system,
            gamma,
            delta,
            ast: Some(witness_with_ast.ast),
        })
    }

    /// Convert Dory witness collection to DoryRecursionWitness
    fn witnesses_to_dory_recursion(
        witnesses: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<crate::zkvm::recursion::witness::GTCombineWitness>,
    ) -> Result<DoryRecursionWitness, Box<dyn std::error::Error>> {
        let _span = tracing::info_span!("witnesses_to_dory_recursion").entered();

        use crate::zkvm::recursion::witness::{GTExpWitness, GTMulWitness};

        tracing::debug!(
            "Converting witnesses: GT exp count = {}, GT mul count = {}, G1 scalar mul count = {}",
            witnesses.gt_exp.len(),
            witnesses.gt_mul.len(),
            witnesses.g1_scalar_mul.len()
        );

        // Extract GT exp witness data with preallocation
        let gt_exp_span = tracing::info_span!("process_gt_exp_witnesses").entered();

        // Calculate total sizes for preallocation
        let total_bits = witnesses.gt_exp.values().map(|w| w.bits.len()).sum();
        let total_rho_elements: usize = witnesses
            .gt_exp
            .values()
            .map(|w| w.rho_mles.iter().map(|mle| mle.len()).sum::<usize>())
            .sum();
        let total_quotient_elements: usize = witnesses
            .gt_exp
            .values()
            .map(|w| w.quotient_mles.iter().map(|mle| mle.len()).sum::<usize>())
            .sum();

        let mut bits = Vec::with_capacity(total_bits);
        let mut base_values = Vec::with_capacity(total_rho_elements);
        let mut rho_values = Vec::with_capacity(total_rho_elements);
        let mut quotient_values = Vec::with_capacity(total_quotient_elements);
        let mut scalar = Fr::zero();

        // Process GT exp witnesses (deterministic order by OpId)
        let mut gt_exp_items: Vec<_> = witnesses.gt_exp.iter().collect();
        gt_exp_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, exp_witness) in gt_exp_items {
            // Extract the scalar from the first witness
            if scalar.is_zero() && !exp_witness.exponent.is_zero() {
                scalar = exp_witness.exponent;
            }

            // Collect bits
            bits.extend(&exp_witness.bits);

            // Process rho MLEs once, copying to both vectors
            for rho_mle in &exp_witness.rho_mles {
                base_values.extend(rho_mle);
                rho_values.extend(rho_mle);
            }

            // Extract quotient values from MLEs
            for quotient_mle in &exp_witness.quotient_mles {
                quotient_values.extend(quotient_mle);
            }
        }
        drop(gt_exp_span);

        // Get the proper g(x) polynomial from jolt_optimizations
        // This is the irreducible polynomial defining the Fq12 extension field
        let g_poly_span = tracing::info_span!("process_g_polynomial").entered();
        use super::constraints_sys::DoryMatrixBuilder;
        use jolt_optimizations::get_g_mle;

        let g_mle_4var = get_g_mle();

        // Pad g(x) to 11 variables (matching constraint system)
        let g_poly_values = DoryMatrixBuilder::pad_4var_to_11var_zero_padding(&g_mle_4var);
        let g_poly = DensePolynomial::new(g_poly_values.clone());
        let g_values = g_poly_values;
        drop(g_poly_span);

        let gt_exp_witness = GTExpWitness {
            g_poly,
            g_values,
            scalar,
            bits,
            base_values,
            rho_values,
            quotient_values,
        };

        // Extract GT mul witness data with preallocation
        let gt_mul_span = tracing::info_span!("process_gt_mul_witnesses").entered();

        let total_mul_quotient_elements: usize = witnesses
            .gt_mul
            .values()
            .map(|w| w.quotient_mle.len())
            .sum();

        let mut lhs_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut rhs_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut result_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut gt_mul_quotient_values = Vec::with_capacity(total_mul_quotient_elements);

        // Deterministic order by OpId
        let mut gt_mul_items: Vec<_> = witnesses.gt_mul.iter().collect();
        gt_mul_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, mul_witness) in gt_mul_items {
            // For GT multiplication, we work with the quotient MLEs which are already in Fq
            // The actual lhs, rhs, result values come from the quotient decomposition
            gt_mul_quotient_values.extend(&mul_witness.quotient_mle);

            // For now, use placeholder values for lhs/rhs/result
            // In practice, these would be extracted from the quotient decomposition
            if !mul_witness.quotient_mle.is_empty() {
                lhs_values.push(mul_witness.quotient_mle[0]);
                rhs_values.push(mul_witness.quotient_mle[0]);
                result_values.push(mul_witness.quotient_mle[0]);
            }
        }
        drop(gt_mul_span);

        let gt_mul_witness = GTMulWitness {
            lhs_values,
            rhs_values,
            result_values,
            quotient_values: gt_mul_quotient_values,
        };

        // Extract G1 scalar mul witness data with preallocation
        let g1_scalar_mul_span = tracing::info_span!("process_g1_scalar_mul_witnesses").entered();

        let num_g1_witnesses = witnesses.g1_scalar_mul.len();
        let total_bits: usize = witnesses.g1_scalar_mul.values().map(|w| w.bits.len()).sum();

        let mut base_points = Vec::with_capacity(num_g1_witnesses);
        let mut scalars = Vec::with_capacity(num_g1_witnesses);
        let mut x_a_mles = Vec::new();
        let mut y_a_mles = Vec::new();
        let mut x_t_mles = Vec::new();
        let mut y_t_mles = Vec::new();
        let mut x_a_next_mles = Vec::new();
        let mut y_a_next_mles = Vec::new();
        let mut t_is_infinity_mles = Vec::with_capacity(total_bits);

        let mut g1_items: Vec<_> = witnesses.g1_scalar_mul.iter().collect();
        g1_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, scalar_mul_witness) in g1_items {
            base_points.push(scalar_mul_witness.point_base);
            scalars.push(scalar_mul_witness.scalar);

            // Use iterators to avoid cloning - just extend from the slice
            x_a_mles.extend_from_slice(&scalar_mul_witness.x_a_mles);
            y_a_mles.extend_from_slice(&scalar_mul_witness.y_a_mles);
            x_t_mles.extend_from_slice(&scalar_mul_witness.x_t_mles);
            y_t_mles.extend_from_slice(&scalar_mul_witness.y_t_mles);
            x_a_next_mles.extend_from_slice(&scalar_mul_witness.x_a_next_mles);
            y_a_next_mles.extend_from_slice(&scalar_mul_witness.y_a_next_mles);

            // Generate t_is_infinity MLEs based on the bits
            for bit in scalar_mul_witness.bits.iter() {
                // T is infinity when bit is 0 (we don't add)
                let is_infinity = if !bit { Fq::one() } else { Fq::zero() };
                t_is_infinity_mles.push(vec![is_infinity]);
            }
        }
        drop(g1_scalar_mul_span);

        let g1_scalar_mul_witness = G1ScalarMulWitness {
            base_points,
            scalars,
            x_a_mles,
            y_a_mles,
            x_t_mles,
            y_t_mles,
            x_a_next_mles,
            y_a_next_mles,
            t_is_infinity_mles,
        };

        // Extract G1Add witnesses from dory collection
        let g1_add_witness = {
            let mut items: Vec<_> = witnesses.g1_add.iter().collect();
            items.sort_by_key(|(op_id, _)| *op_id);
            super::witness::G1AddWitness {
                x_p_mles: items.iter().map(|(_, w)| vec![w.x_p]).collect(),
                y_p_mles: items.iter().map(|(_, w)| vec![w.y_p]).collect(),
                ind_p_mles: items.iter().map(|(_, w)| vec![w.ind_p]).collect(),
                x_q_mles: items.iter().map(|(_, w)| vec![w.x_q]).collect(),
                y_q_mles: items.iter().map(|(_, w)| vec![w.y_q]).collect(),
                ind_q_mles: items.iter().map(|(_, w)| vec![w.ind_q]).collect(),
                x_r_mles: items.iter().map(|(_, w)| vec![w.x_r]).collect(),
                y_r_mles: items.iter().map(|(_, w)| vec![w.y_r]).collect(),
                ind_r_mles: items.iter().map(|(_, w)| vec![w.ind_r]).collect(),
                lambda_mles: items.iter().map(|(_, w)| vec![w.lambda]).collect(),
                inv_dx_mles: items.iter().map(|(_, w)| vec![w.inv_delta_x]).collect(),
                is_double_mles: items.iter().map(|(_, w)| vec![w.is_double]).collect(),
                is_inverse_mles: items.iter().map(|(_, w)| vec![w.is_inverse]).collect(),
            }
        };

        // Extract G2Add witnesses from dory collection
        let g2_add_witness = {
            let mut items: Vec<_> = witnesses.g2_add.iter().collect();
            items.sort_by_key(|(op_id, _)| *op_id);
            super::witness::G2AddWitness {
                x_p_c0_mles: items.iter().map(|(_, w)| vec![w.x_p_c0]).collect(),
                x_p_c1_mles: items.iter().map(|(_, w)| vec![w.x_p_c1]).collect(),
                y_p_c0_mles: items.iter().map(|(_, w)| vec![w.y_p_c0]).collect(),
                y_p_c1_mles: items.iter().map(|(_, w)| vec![w.y_p_c1]).collect(),
                ind_p_mles: items.iter().map(|(_, w)| vec![w.ind_p]).collect(),
                x_q_c0_mles: items.iter().map(|(_, w)| vec![w.x_q_c0]).collect(),
                x_q_c1_mles: items.iter().map(|(_, w)| vec![w.x_q_c1]).collect(),
                y_q_c0_mles: items.iter().map(|(_, w)| vec![w.y_q_c0]).collect(),
                y_q_c1_mles: items.iter().map(|(_, w)| vec![w.y_q_c1]).collect(),
                ind_q_mles: items.iter().map(|(_, w)| vec![w.ind_q]).collect(),
                x_r_c0_mles: items.iter().map(|(_, w)| vec![w.x_r_c0]).collect(),
                x_r_c1_mles: items.iter().map(|(_, w)| vec![w.x_r_c1]).collect(),
                y_r_c0_mles: items.iter().map(|(_, w)| vec![w.y_r_c0]).collect(),
                y_r_c1_mles: items.iter().map(|(_, w)| vec![w.y_r_c1]).collect(),
                ind_r_mles: items.iter().map(|(_, w)| vec![w.ind_r]).collect(),
                lambda_c0_mles: items.iter().map(|(_, w)| vec![w.lambda_c0]).collect(),
                lambda_c1_mles: items.iter().map(|(_, w)| vec![w.lambda_c1]).collect(),
                inv_dx_c0_mles: items.iter().map(|(_, w)| vec![w.inv_delta_x_c0]).collect(),
                inv_dx_c1_mles: items.iter().map(|(_, w)| vec![w.inv_delta_x_c1]).collect(),
                is_double_mles: items.iter().map(|(_, w)| vec![w.is_double]).collect(),
                is_inverse_mles: items.iter().map(|(_, w)| vec![w.is_inverse]).collect(),
            }
        };

        if let Some(ref cw) = combine_witness {
            tracing::info!(
                "[Homomorphic Combine] Merging combine_witness: {} exp ops, {} mul ops",
                cw.exp_witnesses.len(),
                cw.mul_witnesses.len()
            );
        }

        Ok(DoryRecursionWitness {
            gt_exp_witness,
            gt_mul_witness,
            g1_scalar_mul_witness,
            g1_add_witness,
            g2_add_witness,
            #[cfg(feature = "experimental-pairing-recursion")]
            multi_miller_loop_witness: Default::default(),
            combine_witness,
        })
    }

    /// Build constraint system from recursion witness
    fn build_constraint_system(
        witness_collection: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<&crate::zkvm::recursion::witness::GTCombineWitness>,
        g_poly: DensePolynomial<Fq>,
    ) -> Result<ConstraintSystem, Box<dyn std::error::Error>> {
        use super::constraints_sys::DoryMatrixBuilder;
        use super::stage1::gt_exp::PackedGtExpWitness;
        use super::stage2::g1_scalar_mul::G1ScalarMulPublicInputs;
        use super::stage2::g2_scalar_mul::G2ScalarMulPublicInputs;
        use jolt_optimizations::fq12_to_multilinear_evals;

        // Constraint-family toggles (useful to isolate failures).
        // Defaults enable the full constraint set; disable families by setting env vars to "0".
        let env_flag_default = |name: &str, default: bool| -> bool {
            std::env::var(name)
                .ok()
                .map(|v| v != "0" && v.to_lowercase() != "false")
                .unwrap_or(default)
        };
        let enable_gt_mul = env_flag_default("JOLT_RECURSION_ENABLE_GT_MUL", true);
        let enable_g1_scalar_mul = env_flag_default("JOLT_RECURSION_ENABLE_G1_SCALAR_MUL", true);
        let enable_g2_scalar_mul = env_flag_default("JOLT_RECURSION_ENABLE_G2_SCALAR_MUL", true);
        let enable_g1_add = env_flag_default("JOLT_RECURSION_ENABLE_G1_ADD", true);
        let enable_g2_add = env_flag_default("JOLT_RECURSION_ENABLE_G2_ADD", true);

        // Use DoryMatrixBuilder with 11 variables for uniform matrix structure (packed GT exp)
        let mut builder = DoryMatrixBuilder::new(11);

        // Build packed GT exp witnesses and add to matrix
        tracing::info!(
            "[build_constraint_system] Processing {} direct GT exp witnesses",
            witness_collection.gt_exp.len()
        );
        let gt_exp_span = tracing::info_span!(
            "build_gt_exp_witnesses",
            count = witness_collection.gt_exp.len()
        )
        .entered();
        let mut gt_exp_witnesses = Vec::with_capacity(witness_collection.gt_exp.len());
        let mut gt_exp_public_inputs = Vec::with_capacity(witness_collection.gt_exp.len());
        let mut g1_scalar_mul_public_inputs =
            Vec::with_capacity(witness_collection.g1_scalar_mul.len());
        let mut g2_scalar_mul_public_inputs =
            Vec::with_capacity(witness_collection.g2_scalar_mul.len());
        // Deterministic order by OpId
        let mut gt_exp_items: Vec<_> = witness_collection.gt_exp.iter().collect();
        gt_exp_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, witness) in gt_exp_items {
            // Convert base ArkGT to 4-var MLE
            let base_mle = fq12_to_multilinear_evals(&witness.base);
            let base2_mle = fq12_to_multilinear_evals(&(witness.base * witness.base));
            let base3_mle =
                fq12_to_multilinear_evals(&(witness.base * witness.base * witness.base));

            // Create packed witness
            let packed = PackedGtExpWitness::from_steps(
                &witness.rho_mles,
                &witness.quotient_mles,
                &witness.bits,
                &base_mle,
                &base2_mle,
                &base3_mle,
            );

            // Add to matrix (ONE constraint per packed GT exp)
            builder.add_gt_exp_witness(&packed);

            // Keep for Stage 1 prover
            gt_exp_witnesses.push(packed);

            // Store public inputs for verifier
            gt_exp_public_inputs.push(PackedGtExpPublicInputs::new(
                witness.base,
                witness.bits.clone(),
            ));
        }
        drop(gt_exp_span);

        // Add GT mul witnesses (optional)
        if enable_gt_mul {
            let gt_mul_span = tracing::info_span!(
                "add_gt_mul_witnesses",
                count = witness_collection.gt_mul.len()
            )
            .entered();
            let mut gt_mul_items: Vec<_> = witness_collection.gt_mul.iter().collect();
            gt_mul_items.sort_by_key(|(op_id, _)| *op_id);
            for (_op_id, witness) in gt_mul_items {
                builder.add_gt_mul_witness(witness);
            }
            drop(gt_mul_span);
        }

        // Add G1 scalar mul witnesses (optional)
        if enable_g1_scalar_mul {
            let g1_scalar_mul_span = tracing::info_span!(
                "add_g1_scalar_mul_witnesses",
                count = witness_collection.g1_scalar_mul.len()
            )
            .entered();
            let mut g1_items: Vec<_> = witness_collection.g1_scalar_mul.iter().collect();
            g1_items.sort_by_key(|(op_id, _)| *op_id);
            for (_op_id, witness) in g1_items {
                builder.add_g1_scalar_mul_witness(witness);
                g1_scalar_mul_public_inputs.push(G1ScalarMulPublicInputs::new(witness.scalar));
            }
            drop(g1_scalar_mul_span);
        }

        // Add G2 scalar mul witnesses (optional)
        if enable_g2_scalar_mul {
            let g2_scalar_mul_span = tracing::info_span!(
                "add_g2_scalar_mul_witnesses",
                count = witness_collection.g2_scalar_mul.len()
            )
            .entered();
            let mut g2_items: Vec<_> = witness_collection.g2_scalar_mul.iter().collect();
            g2_items.sort_by_key(|(op_id, _)| *op_id);
            for (_op_id, witness) in g2_items {
                builder.add_g2_scalar_mul_witness(witness);
                g2_scalar_mul_public_inputs.push(G2ScalarMulPublicInputs::new(witness.scalar));
            }
            drop(g2_scalar_mul_span);
        }

        // Add G1 add witnesses (optional; into the matrix)
        if enable_g1_add {
            let g1_add_span = tracing::info_span!(
                "add_g1_add_witnesses",
                count = witness_collection.g1_add.len()
            )
            .entered();
            let mut g1_add_items: Vec<_> = witness_collection.g1_add.iter().collect();
            g1_add_items.sort_by_key(|(op_id, _)| *op_id);
            for (_op_id, witness) in g1_add_items {
                builder.add_g1_add_witness(witness);
            }
            drop(g1_add_span);
        }

        // Add G2 add witnesses (optional; into the matrix)
        if enable_g2_add {
            let g2_add_span = tracing::info_span!(
                "add_g2_add_witnesses",
                count = witness_collection.g2_add.len()
            )
            .entered();
            let mut g2_add_items: Vec<_> = witness_collection.g2_add.iter().collect();
            g2_add_items.sort_by_key(|(op_id, _)| *op_id);
            for (_op_id, witness) in g2_add_items {
                builder.add_g2_add_witness(witness);
            }
            drop(g2_add_span);
        }

        // Add combine_commitments witnesses (homomorphic combine offloading)
        if let Some(cw) = combine_witness {
            let pre_count = builder.constraint_count();
            tracing::info!(
                "[Homomorphic Combine] Adding {} GT exp + {} GT mul constraints (pre-count: {})",
                cw.exp_witnesses.len(),
                cw.mul_witnesses.len(),
                pre_count
            );

            // Also collect public inputs for the combine witnesses
            for exp_wit in &cw.exp_witnesses {
                gt_exp_public_inputs.push(PackedGtExpPublicInputs::new(
                    exp_wit.base,
                    exp_wit.bits.clone(),
                ));
            }

            let combined_packed_witnesses = builder.add_combine_witness(cw);
            tracing::info!(
                "[Homomorphic Combine] Post-add constraint count: {}, packed witnesses: {}",
                builder.constraint_count(),
                combined_packed_witnesses.len()
            );
            // Add the combined witnesses to our list
            tracing::info!(
                "[Homomorphic Combine] Before extend: {} witnesses, adding {} more",
                gt_exp_witnesses.len(),
                combined_packed_witnesses.len()
            );
            gt_exp_witnesses.extend(combined_packed_witnesses);
        }

        let build_matrix_span = tracing::info_span!("build_matrix").entered();
        let (matrix, constraints) = builder.build();
        drop(build_matrix_span);

        Ok(ConstraintSystem {
            constraints,
            matrix,
            g_poly,
            gt_exp_witnesses,
            gt_exp_public_inputs,
            g1_scalar_mul_public_inputs,
            g2_scalar_mul_public_inputs,
            // G1/G2 add constraints are stored in the matrix; Stage 1 extracts them from the matrix.
            g1_add_witnesses: Vec::new(),
            g2_add_witnesses: Vec::new(),
        })
    }
}

impl RecursionProver<Fq> {
    /// Run the full recursion prover and generate PCS opening proof
    pub fn prove<T: Transcript, PCS: CommitmentScheme<Field = Fq> + RecursionExt<Fq>>(
        self,
        transcript: &mut T,
        prover_setup: &PCS::ProverSetup,
    ) -> Result<RecursionProof<Fq, T, PCS>, Box<dyn std::error::Error>> {
        // Delegate to prove_with_pcs - the RecursionExt trait bound is not actually used
        self.prove_with_pcs(transcript, prover_setup)
    }

    /// Run the full recursion prover for any PCS (without requiring RecursionExt)
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_with_pcs")]
    pub fn prove_with_pcs<T: Transcript, PCS: CommitmentScheme<Field = Fq>>(
        self,
        transcript: &mut T,
        prover_setup: &PCS::ProverSetup,
    ) -> Result<RecursionProof<Fq, T, PCS>, Box<dyn std::error::Error>> {
        // Initialize opening accumulator
        let log_T = self.constraint_system.num_vars();
        let mut accumulator = ProverOpeningAccumulator::<Fq>::new(log_T);

        // ============ STAGE 1: Packed GT Exp ============
        tracing::info_span!("recursion_stage1_packed_gt_exp").in_scope(|| {
            tracing::info!("Starting Stage 1: Packed GT exp sumcheck");
        });
        let (stage1_proof, _r_stage1_packed) = self.prove_stage1(transcript, &mut accumulator)?;

        // ============ STAGE 2: Batched Constraint Sumchecks ============
        tracing::info_span!("recursion_stage2_constraint_sumchecks").in_scope(|| {
            tracing::info!("Starting Stage 2: Batched constraint sumchecks");
        });
        // r_x is the shared constraint-binding point used by Stage 3.
        let (stage2_proof, r_x) = self.prove_stage2(transcript, &mut accumulator)?;

        // ============ STAGE 3: Virtualization (direct evaluation) ============
        tracing::info_span!("recursion_stage3_virtualization").in_scope(|| {
            tracing::info!("Starting Stage 3: Virtualization direct evaluation");
        });
        let (stage3_m_eval, r_s) = self.prove_stage3(transcript, &mut accumulator, &r_x)?;

        // ============ STAGE 4: Jagged Transform Sumcheck ============
        tracing::info_span!("recursion_stage4_jagged").in_scope(|| {
            tracing::info!("Starting Stage 4: Jagged transform sumcheck");
        });
        let (stage4_proof, r_dense) =
            self.prove_stage4(transcript, &mut accumulator, &r_s, &r_x)?;

        // ============ STAGE 5: Jagged Assist ============
        tracing::info_span!("recursion_stage5_jagged_assist").in_scope(|| {
            tracing::info!("Starting Stage 5: Jagged assist");
        });
        let stage5_proof = self.prove_stage5(transcript, &mut accumulator, &r_dense, &r_x)?;

        // ============ PCS OPENING PROOF ============
        tracing::info_span!("recursion_pcs_opening_proof").in_scope(|| {
            tracing::info!("Starting PCS opening proof generation");
        });

        // Now we commit to the dense polynomial instead of the full matrix
        let (dense_poly, _bijection, _mapping) = self.constraint_system.build_dense_polynomial();

        // Convert dense polynomial evaluations to F
        let dense_evaluations_f = dense_poly.Z;
        let dense_matrix_poly = MultilinearPolynomial::from(dense_evaluations_f.clone());

        // Commit to the dense polynomial
        let (dense_commitment, _) = PCS::commit(&dense_matrix_poly, prover_setup);

        let mut polynomials_map: HashMap<CommittedPolynomial, MultilinearPolynomial<Fq>> =
            HashMap::new();
        polynomials_map.insert(CommittedPolynomial::DoryDenseMatrix, dense_matrix_poly);

        // Generate opening proof using PCS
        let opening_proof = accumulator
            .prove_single::<T, PCS>(polynomials_map, prover_setup, transcript)
            .map_err(|e| format!("Failed to generate opening proof: {e:?}"))?;

        // Extract opening claims from accumulator
        let opening_claims = accumulator.openings.clone();

        // Create final proof
        let proof = RecursionProof {
            stage1_proof,
            stage2_proof,
            stage3_m_eval,
            stage4_proof,
            stage5_proof,
            opening_proof,
            gamma: self.gamma,
            delta: self.delta,
            opening_claims,
            dense_commitment,
        };

        Ok(proof)
    }

    /// Run Stage 1: Packed GT exp sumcheck
    #[allow(clippy::type_complexity)]
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage1")]
    pub(crate) fn prove_stage1<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<Fq>,
    ) -> Result<
        (
            crate::subprotocols::sumcheck::SumcheckInstanceProof<Fq, T>,
            Vec<<Fq as JoltField>::Challenge>,
        ),
        Box<dyn std::error::Error>,
    > {
        let packed_witnesses = &self.constraint_system.gt_exp_witnesses;
        if packed_witnesses.is_empty() {
            return Err("No PackedGtExp constraints to prove in Stage 1".into());
        }

        // Packed GT exp uses layout x * 128 + s (s in low bits), so g needs replication
        // across the step variables.
        let g_4var: Vec<Fq> = self.constraint_system.g_poly.evals()[0..16].to_vec();
        let g_replicated = DoryMatrixBuilder::pad_4var_to_11var_replicated(&g_4var);
        let g_poly_replicated_f = DensePolynomial::new(g_replicated);

        let params = PackedGtExpParams::new();
        tracing::info!(
            "[Stage 1] Creating PackedGtExpProver with {} witnesses",
            packed_witnesses.len()
        );
        let mut packed_gt_exp_prover =
            PackedGtExpProver::new(params, packed_witnesses, g_poly_replicated_f, transcript);

        // Run the (single-instance) sumcheck.
        let (proof, r_stage1) =
            BatchedSumcheck::prove(vec![&mut packed_gt_exp_prover], accumulator, transcript);

        Ok((proof, r_stage1))
    }

    /// Run Stage 2: Batched constraint sumchecks.
    ///
    /// This stage includes:
    /// - packed-GT-exp internal consistency (`ShiftRho`)
    /// - packed-GT-exp claim reduction to a shared `r_x`
    /// - all remaining constraint families (GT mul, G1/G2 scalar mul, G1/G2 add, ...)
    #[allow(clippy::type_complexity)]
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage2")]
    pub(crate) fn prove_stage2<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<Fq>,
    ) -> Result<
        (
            crate::subprotocols::sumcheck::SumcheckInstanceProof<Fq, T>,
            Vec<<Fq as JoltField>::Challenge>, // r_x
        ),
        Box<dyn std::error::Error>,
    > {
        let env_flag_default = |name: &str, default: bool| -> bool {
            std::env::var(name)
                .ok()
                .map(|v| v != "0" && v.to_lowercase() != "false")
                .unwrap_or(default)
        };
        let enable_shift_rho = env_flag_default("JOLT_RECURSION_ENABLE_SHIFT_RHO", true);
        let enable_shift_g1_scalar_mul =
            env_flag_default("JOLT_RECURSION_ENABLE_SHIFT_G1_SCALAR_MUL", true);
        let enable_shift_g2_scalar_mul =
            env_flag_default("JOLT_RECURSION_ENABLE_SHIFT_G2_SCALAR_MUL", true);
        let enable_claim_reduction =
            env_flag_default("JOLT_RECURSION_ENABLE_PGX_REDUCTION", true);

        let mut provers: Vec<Box<dyn SumcheckInstanceProver<Fq, T>>> = Vec::new();

        // ---- Packed GT exp (shift rho + claim reduction) ----
        let num_gt_exp = self.constraint_system.gt_exp_witnesses.len();
        if num_gt_exp > 0 {
            let claim_indices: Vec<usize> = (0..num_gt_exp).collect();

            if enable_shift_rho {
                let rho_polys: Vec<Vec<Fq>> = self
                    .constraint_system
                    .gt_exp_witnesses
                    .iter()
                    .map(|w| w.rho_packed.clone())
                    .collect();
                let shift_params = ShiftRhoParams::new(num_gt_exp);
                let shift_prover = ShiftRhoProver::<Fq, T>::new(
                    shift_params,
                    rho_polys,
                    claim_indices.clone(),
                    accumulator,
                    transcript,
                );
                provers.push(Box::new(shift_prover));
            }

            if enable_claim_reduction {
                let rho_polys: Vec<MultilinearPolynomial<Fq>> = self
                    .constraint_system
                    .gt_exp_witnesses
                    .iter()
                    .map(|w| MultilinearPolynomial::from(w.rho_packed.clone()))
                    .collect();
                let quotient_polys: Vec<MultilinearPolynomial<Fq>> = self
                    .constraint_system
                    .gt_exp_witnesses
                    .iter()
                    .map(|w| MultilinearPolynomial::from(w.quotient_packed.clone()))
                    .collect();
                let reduction_params = PackedGtExpClaimReductionParams::new(2 * num_gt_exp);
                let reduction_prover = PackedGtExpClaimReductionProver::<Fq, T>::new(
                    reduction_params,
                    &claim_indices,
                    rho_polys,
                    quotient_polys,
                    accumulator,
                    transcript,
                );
                provers.push(Box::new(reduction_prover));
            }
        }

        // ---- GT mul / G1+G2 scalar mul / G1+G2 add (and any other Stage 2 constraints) ----
        //
        // NOTE: These were previously run in Stage 1; we keep their logic but batch them here.

        // Convert g_poly for GT mul (uses zero padding layout: s * 16 + x)
        let g_poly_f = self.constraint_system.g_poly.clone();

        // GT mul
        let gt_mul_constraints_tuples = self.constraint_system.extract_gt_mul_constraints();
        if !gt_mul_constraints_tuples.is_empty() {
            use super::stage2::gt_mul::GtMulConstraintPolynomials;
            let constraint_indices: Vec<usize> = (0..gt_mul_constraints_tuples.len()).collect();
            let gt_mul_constraints_fq: Vec<GtMulConstraintPolynomials<Fq>> = gt_mul_constraints_tuples
                .into_iter()
                .map(|(idx, lhs, rhs, result, quotient)| GtMulConstraintPolynomials {
                    lhs,
                    rhs,
                    result,
                    quotient,
                    constraint_index: idx,
                })
                .collect();

            let params = GtMulParams::new(gt_mul_constraints_fq.len());
            let spec = GtMulProverSpec::new(params, gt_mul_constraints_fq, g_poly_f.clone());
            let prover = GtMulProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // G1 scalar mul
        let g1_scalar_mul_constraints_tuples =
            self.constraint_system.extract_g1_scalar_mul_constraints();
        if !g1_scalar_mul_constraints_tuples.is_empty() {
            use super::stage2::g1_scalar_mul::{
                G1ScalarMulConstraintPolynomials, G1ScalarMulParams, G1ScalarMulProver,
                G1ScalarMulProverSpec,
            };

            debug_assert_eq!(
                self.constraint_system.g1_scalar_mul_public_inputs.len(),
                g1_scalar_mul_constraints_tuples.len(),
                "ConstraintSystem.g1_scalar_mul_public_inputs must match extracted G1 scalar-mul constraints"
            );

            if enable_shift_g1_scalar_mul {
                let mut pairs: Vec<(VirtualPolynomial, Vec<Fq>, VirtualPolynomial, Vec<Fq>)> =
                    Vec::with_capacity(g1_scalar_mul_constraints_tuples.len() * 2);

                for w in &g1_scalar_mul_constraints_tuples {
                    let i = w.constraint_index;
                    let xa = VirtualPolynomial::g1_scalar_mul_xa(i);
                    let xa_next = VirtualPolynomial::g1_scalar_mul_xa_next(i);
                    pairs.push((xa, w.x_a.clone(), xa_next, w.x_a_next.clone()));

                    let ya = VirtualPolynomial::g1_scalar_mul_ya(i);
                    let ya_next = VirtualPolynomial::g1_scalar_mul_ya_next(i);
                    pairs.push((ya, w.y_a.clone(), ya_next, w.y_a_next.clone()));
                }

                let shift_params = g1_shift_params(pairs.len());
                let shift_prover =
                    ShiftG1ScalarMulProver::<Fq, T>::new(shift_params, pairs, transcript);
                provers.push(Box::new(shift_prover));
            }

            let mut g1_scalar_mul_constraints: Vec<G1ScalarMulConstraintPolynomials<Fq>> =
                Vec::with_capacity(g1_scalar_mul_constraints_tuples.len());
            let mut g1_scalar_mul_base_points: Vec<(Fq, Fq)> =
                Vec::with_capacity(g1_scalar_mul_constraints_tuples.len());

            for w in g1_scalar_mul_constraints_tuples {
                g1_scalar_mul_constraints.push(G1ScalarMulConstraintPolynomials {
                    x_a: w.x_a,
                    y_a: w.y_a,
                    x_t: w.x_t,
                    y_t: w.y_t,
                    x_a_next: w.x_a_next,
                    y_a_next: w.y_a_next,
                    t_indicator: w.t_indicator,
                    a_indicator: w.a_indicator,
                    constraint_index: w.constraint_index,
                });
                g1_scalar_mul_base_points.push(w.base_point);
            }

            let params = G1ScalarMulParams::new(g1_scalar_mul_constraints.len());
            let (spec, constraint_indices) = G1ScalarMulProverSpec::new(
                params,
                g1_scalar_mul_constraints,
                &self.constraint_system.g1_scalar_mul_public_inputs,
                g1_scalar_mul_base_points,
            );
            let prover = G1ScalarMulProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // G2 scalar mul
        let g2_scalar_mul_constraints_tuples =
            self.constraint_system.extract_g2_scalar_mul_constraints();
        if !g2_scalar_mul_constraints_tuples.is_empty() {
            use super::stage2::g2_scalar_mul::{
                G2ScalarMulConstraintPolynomials, G2ScalarMulParams, G2ScalarMulProver,
                G2ScalarMulProverSpec,
            };

            debug_assert_eq!(
                self.constraint_system.g2_scalar_mul_public_inputs.len(),
                g2_scalar_mul_constraints_tuples.len(),
                "ConstraintSystem.g2_scalar_mul_public_inputs must match extracted G2 scalar-mul constraints"
            );

            if enable_shift_g2_scalar_mul {
                let mut pairs: Vec<(VirtualPolynomial, Vec<Fq>, VirtualPolynomial, Vec<Fq>)> =
                    Vec::with_capacity(g2_scalar_mul_constraints_tuples.len() * 4);
                for w in &g2_scalar_mul_constraints_tuples {
                    let i = w.constraint_index;
                    let xa_c0 = VirtualPolynomial::g2_scalar_mul_xa_c0(i);
                    let xa_next_c0 = VirtualPolynomial::g2_scalar_mul_xa_next_c0(i);
                    pairs.push((xa_c0, w.x_a_c0.clone(), xa_next_c0, w.x_a_next_c0.clone()));

                    let xa_c1 = VirtualPolynomial::g2_scalar_mul_xa_c1(i);
                    let xa_next_c1 = VirtualPolynomial::g2_scalar_mul_xa_next_c1(i);
                    pairs.push((xa_c1, w.x_a_c1.clone(), xa_next_c1, w.x_a_next_c1.clone()));

                    let ya_c0 = VirtualPolynomial::g2_scalar_mul_ya_c0(i);
                    let ya_next_c0 = VirtualPolynomial::g2_scalar_mul_ya_next_c0(i);
                    pairs.push((ya_c0, w.y_a_c0.clone(), ya_next_c0, w.y_a_next_c0.clone()));

                    let ya_c1 = VirtualPolynomial::g2_scalar_mul_ya_c1(i);
                    let ya_next_c1 = VirtualPolynomial::g2_scalar_mul_ya_next_c1(i);
                    pairs.push((ya_c1, w.y_a_c1.clone(), ya_next_c1, w.y_a_next_c1.clone()));
                }

                let shift_params = g2_shift_params(pairs.len());
                let shift_prover =
                    ShiftG2ScalarMulProver::<Fq, T>::new(shift_params, pairs, transcript);
                provers.push(Box::new(shift_prover));
            }

            let mut g2_scalar_mul_constraints: Vec<G2ScalarMulConstraintPolynomials<Fq>> =
                Vec::with_capacity(g2_scalar_mul_constraints_tuples.len());
            let mut g2_scalar_mul_base_points =
                Vec::with_capacity(g2_scalar_mul_constraints_tuples.len());

            for w in g2_scalar_mul_constraints_tuples {
                g2_scalar_mul_constraints.push(G2ScalarMulConstraintPolynomials {
                    x_a_c0: w.x_a_c0,
                    x_a_c1: w.x_a_c1,
                    y_a_c0: w.y_a_c0,
                    y_a_c1: w.y_a_c1,
                    x_t_c0: w.x_t_c0,
                    x_t_c1: w.x_t_c1,
                    y_t_c0: w.y_t_c0,
                    y_t_c1: w.y_t_c1,
                    x_a_next_c0: w.x_a_next_c0,
                    x_a_next_c1: w.x_a_next_c1,
                    y_a_next_c0: w.y_a_next_c0,
                    y_a_next_c1: w.y_a_next_c1,
                    t_indicator: w.t_indicator,
                    a_indicator: w.a_indicator,
                    constraint_index: w.constraint_index,
                });
                g2_scalar_mul_base_points.push(w.base_point);
            }

            let params = G2ScalarMulParams::new(g2_scalar_mul_constraints.len());
            let (spec, constraint_indices) = G2ScalarMulProverSpec::new(
                params,
                g2_scalar_mul_constraints,
                &self.constraint_system.g2_scalar_mul_public_inputs,
                g2_scalar_mul_base_points,
            );
            let prover = G2ScalarMulProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // G1 add
        let g1_add_constraints = self.constraint_system.extract_g1_add_constraints();
        if !g1_add_constraints.is_empty() {
            use super::stage2::g1_add::{G1AddParams, G1AddProver, G1AddProverSpec};
            let params = G1AddParams::new(g1_add_constraints.len());
            let (spec, constraint_indices) = G1AddProverSpec::new(params, g1_add_constraints);
            let prover = G1AddProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // G2 add
        let g2_add_constraints = self.constraint_system.extract_g2_add_constraints();
        if !g2_add_constraints.is_empty() {
            use super::stage2::g2_add::{G2AddParams, G2AddProver, G2AddProverSpec};
            let params = G2AddParams::new(g2_add_constraints.len());
            let (spec, constraint_indices) = G2AddProverSpec::new(params, g2_add_constraints);
            let prover = G2AddProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // TODO: Add wiring/boundary constraints sumcheck (AST-driven).

        if provers.is_empty() {
            return Err("No constraints to prove in Stage 2".into());
        }

        let (proof, r_x) = BatchedSumcheck::prove(
            provers.iter_mut().map(|p| &mut **p as _).collect(),
            accumulator,
            transcript,
        );

        Ok((proof, r_x))
    }

    /// Run Stage 3: Direct evaluation protocol (virtualization).
    #[allow(clippy::type_complexity)]
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage3")]
    pub(crate) fn prove_stage3<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<Fq>,
        r_x: &[<Fq as JoltField>::Challenge],
    ) -> Result<
        (
            Fq, // M(r_s, r_x)
            Vec<<Fq as JoltField>::Challenge>, // r_s in Stage 4-expected order
        ),
        Box<dyn std::error::Error>,
    > {
        let accumulator_fq: &mut ProverOpeningAccumulator<Fq> = accumulator;
        let r_x_fq: Vec<Fq> = r_x.iter().map(|c| (*c).into()).collect();

        // Extract virtual claims from Stage 2 (note PackedGtExp claims come from claim reduction).
        let constraint_types: Vec<ConstraintType> = self
            .constraint_system
            .constraints
            .iter()
            .map(|c| c.constraint_type.clone())
            .collect();
        let virtual_claims = extract_virtual_claims_from_accumulator(
            accumulator_fq,
            &constraint_types,
            &self.constraint_system.gt_exp_public_inputs,
        );

        let params = DirectEvaluationParams::new(
            self.constraint_system.num_s_vars(),
            self.constraint_system.num_constraints(),
            self.constraint_system.matrix.num_constraints_padded,
            self.constraint_system.matrix.num_constraint_vars,
        );

        let prover = DirectEvaluationProver::new(
            params,
            self.constraint_system.matrix.evaluations.clone(),
            virtual_claims,
            r_x_fq,
        );

        let (r_s, m_eval) = prover.prove(transcript, accumulator_fq);

        let r_s_challenges: Vec<<Fq as JoltField>::Challenge> =
            r_s.into_iter().rev().map(|f| f.into()).collect();

        Ok((m_eval, r_s_challenges))
    }

    /// Run Stage 4: Jagged transform sumcheck.
    #[allow(clippy::type_complexity)]
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage4")]
    pub(crate) fn prove_stage4<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<Fq>,
        r_s: &[<Fq as JoltField>::Challenge],
        r_x: &[<Fq as JoltField>::Challenge],
    ) -> Result<
        (
            crate::subprotocols::sumcheck::SumcheckInstanceProof<Fq, T>,
            Vec<<Fq as JoltField>::Challenge>, // r_dense
        ),
        Box<dyn std::error::Error>,
    > {
        let (_, sparse_claim_value) = accumulator.get_virtual_polynomial_opening(
            VirtualPolynomial::DorySparseConstraintMatrix,
            SumcheckId::RecursionVirtualization,
        );

        let (dense_poly_fq, bijection, mapping) = self.constraint_system.build_dense_polynomial();

        let r_s_final: Vec<Fq> = r_s.iter().map(|c| (*c).into()).collect();
        let r_x_prev: Vec<Fq> = r_x.iter().map(|c| (*c).into()).collect();

        // Precompute matrix row indices for all polynomial indices.
        let num_polynomials = bijection.num_polynomials();
        let mut matrix_rows = Vec::with_capacity(num_polynomials);
        for poly_idx in 0..num_polynomials {
            let (constraint_idx, poly_type) = mapping.decode(poly_idx);
            let matrix_row = self
                .constraint_system
                .matrix
                .row_index(poly_type, constraint_idx);
            matrix_rows.push(matrix_row);
        }

        let mut jagged_prover = JaggedSumcheckProver::new(
            (r_s_final, r_x_prev),
            sparse_claim_value,
            dense_poly_fq,
            bijection,
            mapping,
            matrix_rows,
            transcript,
            self.constraint_system.num_s_vars(),
            self.constraint_system.matrix.num_constraint_vars,
        );

        let (stage4_proof, r_dense) =
            BatchedSumcheck::prove(vec![&mut jagged_prover], accumulator, transcript);

        Ok((stage4_proof, r_dense))
    }

    /// Run Stage 5: Jagged assist (batch MLE verification).
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage5")]
    pub(crate) fn prove_stage5<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<Fq>,
        r_dense: &[<Fq as JoltField>::Challenge],
        r_x: &[<Fq as JoltField>::Challenge],
    ) -> Result<JaggedAssistProof<Fq, T>, Box<dyn std::error::Error>> {
        // Recompute the jagged bijection (needed for K and cumulative sizes).
        let (_dense_poly, bijection, _mapping) = self.constraint_system.build_dense_polynomial();

        let r_x_prev: Vec<Fq> = r_x.iter().map(|c| (*c).into()).collect();
        let r_dense_fq: Vec<Fq> = r_dense.iter().map(|c| (*c).into()).collect();

        let num_constraint_vars = self.constraint_system.matrix.num_constraint_vars;
        let dense_size = <super::bijection::VarCountJaggedBijection as super::bijection::JaggedTransform<Fq>>::dense_size(&bijection);
        let num_dense_vars = dense_size.next_power_of_two().trailing_zeros() as usize;
        let num_bits = std::cmp::max(num_constraint_vars, num_dense_vars);

        let mut assist_prover =
            JaggedAssistProver::<Fq, T>::new(r_x_prev, r_dense_fq, &bijection, num_bits, transcript);

        let (sumcheck_proof, _r_assist) =
            BatchedSumcheck::prove(vec![&mut assist_prover], accumulator, transcript);

        Ok(JaggedAssistProof {
            claimed_evaluations: assist_prover.claimed_evaluations.clone(),
            sumcheck_proof,
        })
    }
}

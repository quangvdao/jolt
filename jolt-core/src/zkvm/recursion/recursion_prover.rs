//! Unified prover for the two-stage recursion SNARK protocol
//!
//! This module provides a high-level prover that orchestrates:
//! - Stage 1: Constraint sumchecks (GT exp, GT mul, G1 scalar mul)
//! - Stage 2: Virtualization sumcheck
//!
//! The prover returns a proof and opening accumulator for PCS verification.

use crate::{
    field::JoltField,
    poly::{
        commitment::{
            commitment_scheme::{CommitmentScheme, RecursionExt},
            dory::{wrappers::ArkDoryProof, ArkworksVerifierSetup, DoryCommitmentScheme},
        },
        dense_mlpoly::DensePolynomial,
        multilinear_polynomial::MultilinearPolynomial,
        opening_proof::{OpeningAccumulator, Openings, ProverOpeningAccumulator, SumcheckId},
    },
    transcripts::Transcript,
    zkvm::{
        recursion::witness::{DoryRecursionWitness, G1ScalarMulWitness},
        witness::{CommittedPolynomial, VirtualPolynomial},
    },
};
use ark_bn254::{Fq, Fr};
use ark_ff::{One, Zero};
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use dory::backends::arkworks::ArkGT;
use std::collections::HashMap;

use crate::zkvm::recursion::DoryMatrixBuilder;
use dory::backends::arkworks::BN254;
use dory::recursion::ast::AstGraph;

use super::{
    constraints_sys::{ConstraintSystem, ConstraintType},
    stage1::gt_exp::{PackedGtExpParams, PackedGtExpProver, PackedGtExpPublicInputs},
    stage2::gt_mul::{GtMulParams, GtMulProver, GtMulProverSpec},
    stage3::virtualization::{
        extract_virtual_claims_from_accumulator, DirectEvaluationParams, DirectEvaluationProver,
    },
    stage4::jagged::JaggedSumcheckProver,
    stage5::jagged_assist::{JaggedAssistProof, JaggedAssistProver},
};
#[cfg(feature = "experimental-pairing-recursion")]
use super::stage1::multi_miller_loop::{MultiMillerLoopParams, MultiMillerLoopProver};
use crate::subprotocols::{sumcheck::BatchedSumcheck, sumcheck_prover::SumcheckInstanceProver};

/// Proof generated by the recursion SNARK
#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct RecursionProof<F: JoltField, T: Transcript, PCS: CommitmentScheme<Field = F>> {
    /// Stage 1 constraint sumcheck proof
    pub stage1_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// Stage 2 direct evaluation result M(r_s, r_x)
    pub stage2_m_eval: F,
    /// Stage 3 jagged transform sumcheck proof
    pub stage3_proof: crate::subprotocols::sumcheck::SumcheckInstanceProof<F, T>,
    /// Stage 3b jagged assist proof (batch MLE verification)
    pub stage3b_proof: JaggedAssistProof<F, T>,
    /// PCS opening proof for the constraint matrix
    pub opening_proof: PCS::Proof,
    /// Gamma value used for batching constraints
    pub gamma: F,
    /// Delta value used for batching within constraints
    pub delta: F,
    /// Opening claims for virtual polynomials
    pub opening_claims: Openings<F>,
    /// Dense polynomial commitment after jagged transform
    pub dense_commitment: PCS::Commitment,
}

/// Unified prover for the recursion SNARK
#[derive(Clone)]
pub struct RecursionProver<F: JoltField = Fq> {
    /// The constraint system containing all constraints and witness data
    pub constraint_system: ConstraintSystem,
    /// Gamma value for batching across constraints
    pub gamma: F,
    /// Delta value for batching within constraints
    pub delta: F,
    /// AST graph for wiring constraints (optional, only present when using AST-enabled mode)
    pub ast: Option<AstGraph<BN254>>,
}

impl RecursionProver<Fq> {
    /// Create a new recursion prover from pre-generated witnesses
    pub fn new_from_witnesses(
        witness_collection: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<crate::zkvm::recursion::witness::GTCombineWitness>,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        tracing::debug!(
            "Creating RecursionProver from witnesses: GT exp count = {}, GT mul count = {}",
            witness_collection.gt_exp.len(),
            witness_collection.gt_mul.len()
        );

        // Convert witness collection to DoryRecursionWitness
        let recursion_witness =
            Self::witnesses_to_dory_recursion(witness_collection, combine_witness.clone())?;

        // Build constraint system from witness collection using DoryMatrixBuilder
        let build_cs_span = tracing::info_span!("build_constraint_system").entered();
        let constraint_system = Self::build_constraint_system(
            witness_collection,
            recursion_witness.combine_witness.as_ref(),
            recursion_witness.gt_exp_witness.g_poly.clone(),
        )?;
        drop(build_cs_span);

        Ok(Self {
            constraint_system,
            gamma,
            delta,
            ast: None,
        })
    }

    /// Create a new recursion prover by generating witnesses from a Dory proof
    #[allow(clippy::too_many_arguments)]
    pub fn new_from_dory_proof<T: Transcript>(
        dory_proof: &ArkDoryProof,
        verifier_setup: &ArkworksVerifierSetup,
        transcript: &mut T,
        point: &[<Fr as JoltField>::Challenge],
        evaluation: &Fr,
        commitment: &ArkGT,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        // Use Dory's witness_gen to generate witnesses
        let (witness_collection, _hints) = DoryCommitmentScheme::witness_gen(
            dory_proof,
            verifier_setup,
            transcript,
            point,
            evaluation,
            commitment,
        )?;

        // Delegate to new_from_witnesses (no combine_witness from direct Dory proof)
        Self::new_from_witnesses(&witness_collection, None, gamma, delta)
    }

    /// Create a new recursion prover with AST tracing enabled.
    ///
    /// This captures the full computation DAG, enabling:
    /// - Deterministic constraint ordering (by topological sort of AST nodes)
    /// - Wiring constraint derivation (from AST edges)
    /// - Boundary constraint identification (from AST roots and leaves)
    #[allow(clippy::too_many_arguments)]
    pub fn new_from_dory_proof_with_ast<T: Transcript>(
        dory_proof: &ArkDoryProof,
        verifier_setup: &ArkworksVerifierSetup,
        transcript: &mut T,
        point: &[<Fr as JoltField>::Challenge],
        evaluation: &Fr,
        commitment: &ArkGT,
        gamma: Fq,
        delta: Fq,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        use crate::poly::commitment::dory::recursion::witness_gen_with_ast;

        // Use AST-enabled witness generation
        let witness_with_ast = witness_gen_with_ast(
            dory_proof,
            verifier_setup,
            transcript,
            point,
            evaluation,
            commitment,
        )?;

        // Convert witness collection to DoryRecursionWitness
        let recursion_witness =
            Self::witnesses_to_dory_recursion(&witness_with_ast.witnesses, None)?;

        // Build constraint system from witness collection
        let build_cs_span = tracing::info_span!("build_constraint_system_with_ast").entered();
        let constraint_system = Self::build_constraint_system(
            &witness_with_ast.witnesses,
            recursion_witness.combine_witness.as_ref(),
            recursion_witness.gt_exp_witness.g_poly.clone(),
        )?;
        drop(build_cs_span);

        Ok(Self {
            constraint_system,
            gamma,
            delta,
            ast: Some(witness_with_ast.ast),
        })
    }

    /// Convert Dory witness collection to DoryRecursionWitness
    fn witnesses_to_dory_recursion(
        witnesses: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<crate::zkvm::recursion::witness::GTCombineWitness>,
    ) -> Result<DoryRecursionWitness, Box<dyn std::error::Error>> {
        let _span = tracing::info_span!("witnesses_to_dory_recursion").entered();

        use crate::zkvm::recursion::witness::{GTExpWitness, GTMulWitness};

        tracing::debug!(
            "Converting witnesses: GT exp count = {}, GT mul count = {}, G1 scalar mul count = {}",
            witnesses.gt_exp.len(),
            witnesses.gt_mul.len(),
            witnesses.g1_scalar_mul.len()
        );

        // Extract GT exp witness data with preallocation
        let gt_exp_span = tracing::info_span!("process_gt_exp_witnesses").entered();

        // Calculate total sizes for preallocation
        let total_bits = witnesses.gt_exp.values().map(|w| w.bits.len()).sum();
        let total_rho_elements: usize = witnesses
            .gt_exp
            .values()
            .map(|w| w.rho_mles.iter().map(|mle| mle.len()).sum::<usize>())
            .sum();
        let total_quotient_elements: usize = witnesses
            .gt_exp
            .values()
            .map(|w| w.quotient_mles.iter().map(|mle| mle.len()).sum::<usize>())
            .sum();

        let mut bits = Vec::with_capacity(total_bits);
        let mut base_values = Vec::with_capacity(total_rho_elements);
        let mut rho_values = Vec::with_capacity(total_rho_elements);
        let mut quotient_values = Vec::with_capacity(total_quotient_elements);
        let mut scalar = Fr::zero();

        // Process GT exp witnesses (deterministic order by OpId)
        let mut gt_exp_items: Vec<_> = witnesses.gt_exp.iter().collect();
        gt_exp_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, exp_witness) in gt_exp_items {
            // Extract the scalar from the first witness
            if scalar.is_zero() && !exp_witness.exponent.is_zero() {
                scalar = exp_witness.exponent;
            }

            // Collect bits
            bits.extend(&exp_witness.bits);

            // Process rho MLEs once, copying to both vectors
            for rho_mle in &exp_witness.rho_mles {
                base_values.extend(rho_mle);
                rho_values.extend(rho_mle);
            }

            // Extract quotient values from MLEs
            for quotient_mle in &exp_witness.quotient_mles {
                quotient_values.extend(quotient_mle);
            }
        }
        drop(gt_exp_span);

        // Get the proper g(x) polynomial from jolt_optimizations
        // This is the irreducible polynomial defining the Fq12 extension field
        let g_poly_span = tracing::info_span!("process_g_polynomial").entered();
        use super::constraints_sys::DoryMatrixBuilder;
        use jolt_optimizations::get_g_mle;

        let g_mle_4var = get_g_mle();

        // Pad g(x) to 11 variables (matching constraint system)
        let g_poly_values = DoryMatrixBuilder::pad_4var_to_11var_zero_padding(&g_mle_4var);
        let g_poly = DensePolynomial::new(g_poly_values.clone());
        let g_values = g_poly_values;
        drop(g_poly_span);

        let gt_exp_witness = GTExpWitness {
            g_poly,
            g_values,
            scalar,
            bits,
            base_values,
            rho_values,
            quotient_values,
        };

        // Extract GT mul witness data with preallocation
        let gt_mul_span = tracing::info_span!("process_gt_mul_witnesses").entered();

        let total_mul_quotient_elements: usize = witnesses
            .gt_mul
            .values()
            .map(|w| w.quotient_mle.len())
            .sum();

        let mut lhs_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut rhs_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut result_values = Vec::with_capacity(witnesses.gt_mul.len());
        let mut gt_mul_quotient_values = Vec::with_capacity(total_mul_quotient_elements);

        // Deterministic order by OpId
        let mut gt_mul_items: Vec<_> = witnesses.gt_mul.iter().collect();
        gt_mul_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, mul_witness) in gt_mul_items {
            // For GT multiplication, we work with the quotient MLEs which are already in Fq
            // The actual lhs, rhs, result values come from the quotient decomposition
            gt_mul_quotient_values.extend(&mul_witness.quotient_mle);

            // For now, use placeholder values for lhs/rhs/result
            // In practice, these would be extracted from the quotient decomposition
            if !mul_witness.quotient_mle.is_empty() {
                lhs_values.push(mul_witness.quotient_mle[0]);
                rhs_values.push(mul_witness.quotient_mle[0]);
                result_values.push(mul_witness.quotient_mle[0]);
            }
        }
        drop(gt_mul_span);

        let gt_mul_witness = GTMulWitness {
            lhs_values,
            rhs_values,
            result_values,
            quotient_values: gt_mul_quotient_values,
        };

        // Extract G1 scalar mul witness data with preallocation
        let g1_scalar_mul_span = tracing::info_span!("process_g1_scalar_mul_witnesses").entered();

        let num_g1_witnesses = witnesses.g1_scalar_mul.len();
        let total_bits: usize = witnesses.g1_scalar_mul.values().map(|w| w.bits.len()).sum();

        let mut base_points = Vec::with_capacity(num_g1_witnesses);
        let mut scalars = Vec::with_capacity(num_g1_witnesses);
        let mut x_a_mles = Vec::new();
        let mut y_a_mles = Vec::new();
        let mut x_t_mles = Vec::new();
        let mut y_t_mles = Vec::new();
        let mut x_a_next_mles = Vec::new();
        let mut y_a_next_mles = Vec::new();
        let mut t_is_infinity_mles = Vec::with_capacity(total_bits);

        let mut g1_items: Vec<_> = witnesses.g1_scalar_mul.iter().collect();
        g1_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, scalar_mul_witness) in g1_items {
            base_points.push(scalar_mul_witness.point_base);
            scalars.push(scalar_mul_witness.scalar);

            // Use iterators to avoid cloning - just extend from the slice
            x_a_mles.extend_from_slice(&scalar_mul_witness.x_a_mles);
            y_a_mles.extend_from_slice(&scalar_mul_witness.y_a_mles);
            x_t_mles.extend_from_slice(&scalar_mul_witness.x_t_mles);
            y_t_mles.extend_from_slice(&scalar_mul_witness.y_t_mles);
            x_a_next_mles.extend_from_slice(&scalar_mul_witness.x_a_next_mles);
            y_a_next_mles.extend_from_slice(&scalar_mul_witness.y_a_next_mles);

            // Generate t_is_infinity MLEs based on the bits
            for bit in scalar_mul_witness.bits.iter() {
                // T is infinity when bit is 0 (we don't add)
                let is_infinity = if !bit { Fq::one() } else { Fq::zero() };
                t_is_infinity_mles.push(vec![is_infinity]);
            }
        }
        drop(g1_scalar_mul_span);

        let g1_scalar_mul_witness = G1ScalarMulWitness {
            base_points,
            scalars,
            x_a_mles,
            y_a_mles,
            x_t_mles,
            y_t_mles,
            x_a_next_mles,
            y_a_next_mles,
            t_is_infinity_mles,
        };

        // Extract G1Add witnesses from dory collection
        let g1_add_witness = {
            let mut items: Vec<_> = witnesses.g1_add.iter().collect();
            items.sort_by_key(|(op_id, _)| *op_id);
            super::witness::G1AddWitness {
                x_p_mles: items.iter().map(|(_, w)| vec![w.x_p]).collect(),
                y_p_mles: items.iter().map(|(_, w)| vec![w.y_p]).collect(),
                ind_p_mles: items.iter().map(|(_, w)| vec![w.ind_p]).collect(),
                x_q_mles: items.iter().map(|(_, w)| vec![w.x_q]).collect(),
                y_q_mles: items.iter().map(|(_, w)| vec![w.y_q]).collect(),
                ind_q_mles: items.iter().map(|(_, w)| vec![w.ind_q]).collect(),
                x_r_mles: items.iter().map(|(_, w)| vec![w.x_r]).collect(),
                y_r_mles: items.iter().map(|(_, w)| vec![w.y_r]).collect(),
                ind_r_mles: items.iter().map(|(_, w)| vec![w.ind_r]).collect(),
                lambda_mles: items.iter().map(|(_, w)| vec![w.lambda]).collect(),
                inv_dx_mles: items.iter().map(|(_, w)| vec![w.inv_delta_x]).collect(),
                is_double_mles: items.iter().map(|(_, w)| vec![w.is_double]).collect(),
                is_inverse_mles: items.iter().map(|(_, w)| vec![w.is_inverse]).collect(),
            }
        };

        // Extract G2Add witnesses from dory collection
        let g2_add_witness = {
            let mut items: Vec<_> = witnesses.g2_add.iter().collect();
            items.sort_by_key(|(op_id, _)| *op_id);
            super::witness::G2AddWitness {
                x_p_c0_mles: items.iter().map(|(_, w)| vec![w.x_p_c0]).collect(),
                x_p_c1_mles: items.iter().map(|(_, w)| vec![w.x_p_c1]).collect(),
                y_p_c0_mles: items.iter().map(|(_, w)| vec![w.y_p_c0]).collect(),
                y_p_c1_mles: items.iter().map(|(_, w)| vec![w.y_p_c1]).collect(),
                ind_p_mles: items.iter().map(|(_, w)| vec![w.ind_p]).collect(),
                x_q_c0_mles: items.iter().map(|(_, w)| vec![w.x_q_c0]).collect(),
                x_q_c1_mles: items.iter().map(|(_, w)| vec![w.x_q_c1]).collect(),
                y_q_c0_mles: items.iter().map(|(_, w)| vec![w.y_q_c0]).collect(),
                y_q_c1_mles: items.iter().map(|(_, w)| vec![w.y_q_c1]).collect(),
                ind_q_mles: items.iter().map(|(_, w)| vec![w.ind_q]).collect(),
                x_r_c0_mles: items.iter().map(|(_, w)| vec![w.x_r_c0]).collect(),
                x_r_c1_mles: items.iter().map(|(_, w)| vec![w.x_r_c1]).collect(),
                y_r_c0_mles: items.iter().map(|(_, w)| vec![w.y_r_c0]).collect(),
                y_r_c1_mles: items.iter().map(|(_, w)| vec![w.y_r_c1]).collect(),
                ind_r_mles: items.iter().map(|(_, w)| vec![w.ind_r]).collect(),
                lambda_c0_mles: items.iter().map(|(_, w)| vec![w.lambda_c0]).collect(),
                lambda_c1_mles: items.iter().map(|(_, w)| vec![w.lambda_c1]).collect(),
                inv_dx_c0_mles: items.iter().map(|(_, w)| vec![w.inv_delta_x_c0]).collect(),
                inv_dx_c1_mles: items.iter().map(|(_, w)| vec![w.inv_delta_x_c1]).collect(),
                is_double_mles: items.iter().map(|(_, w)| vec![w.is_double]).collect(),
                is_inverse_mles: items.iter().map(|(_, w)| vec![w.is_inverse]).collect(),
            }
        };

        if let Some(ref cw) = combine_witness {
            tracing::info!(
                "[Homomorphic Combine] Merging combine_witness: {} exp ops, {} mul ops",
                cw.exp_witnesses.len(),
                cw.mul_witnesses.len()
            );
        }

        Ok(DoryRecursionWitness {
            gt_exp_witness,
            gt_mul_witness,
            g1_scalar_mul_witness,
            g1_add_witness,
            g2_add_witness,
            #[cfg(feature = "experimental-pairing-recursion")]
            multi_miller_loop_witness: Default::default(),
            combine_witness,
        })
    }

    /// Build constraint system from recursion witness
    fn build_constraint_system(
        witness_collection: &dory::recursion::WitnessCollection<
            crate::poly::commitment::dory::recursion::JoltWitness,
        >,
        combine_witness: Option<&crate::zkvm::recursion::witness::GTCombineWitness>,
        g_poly: DensePolynomial<Fq>,
    ) -> Result<ConstraintSystem, Box<dyn std::error::Error>> {
        use super::constraints_sys::DoryMatrixBuilder;
        use super::stage1::gt_exp::PackedGtExpWitness;
        use super::stage2::g1_scalar_mul::G1ScalarMulPublicInputs;
        use super::stage2::g2_scalar_mul::G2ScalarMulPublicInputs;
        use jolt_optimizations::fq12_to_multilinear_evals;

        // Use DoryMatrixBuilder with 11 variables for uniform matrix structure (packed GT exp)
        let mut builder = DoryMatrixBuilder::new(11);

        // Build packed GT exp witnesses and add to matrix
        tracing::info!(
            "[build_constraint_system] Processing {} direct GT exp witnesses",
            witness_collection.gt_exp.len()
        );
        let gt_exp_span = tracing::info_span!(
            "build_gt_exp_witnesses",
            count = witness_collection.gt_exp.len()
        )
        .entered();
        let mut gt_exp_witnesses = Vec::with_capacity(witness_collection.gt_exp.len());
        let mut gt_exp_public_inputs = Vec::with_capacity(witness_collection.gt_exp.len());
        let mut g1_scalar_mul_public_inputs =
            Vec::with_capacity(witness_collection.g1_scalar_mul.len());
        let mut g2_scalar_mul_public_inputs =
            Vec::with_capacity(witness_collection.g2_scalar_mul.len());
        // Deterministic order by OpId
        let mut gt_exp_items: Vec<_> = witness_collection.gt_exp.iter().collect();
        gt_exp_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, witness) in gt_exp_items {
            // Convert base ArkGT to 4-var MLE
            let base_mle = fq12_to_multilinear_evals(&witness.base);
            let base2_mle = fq12_to_multilinear_evals(&(witness.base * witness.base));
            let base3_mle =
                fq12_to_multilinear_evals(&(witness.base * witness.base * witness.base));

            // Create packed witness
            let packed = PackedGtExpWitness::from_steps(
                &witness.rho_mles,
                &witness.quotient_mles,
                &witness.bits,
                &base_mle,
                &base2_mle,
                &base3_mle,
            );

            // Add to matrix (ONE constraint per packed GT exp)
            builder.add_gt_exp_witness(&packed);

            // Keep for Stage 1 prover
            gt_exp_witnesses.push(packed);

            // Store public inputs for verifier
            gt_exp_public_inputs.push(PackedGtExpPublicInputs::new(
                witness.base,
                witness.bits.clone(),
            ));
        }
        drop(gt_exp_span);

        // Add GT mul witnesses
        let gt_mul_span = tracing::info_span!(
            "add_gt_mul_witnesses",
            count = witness_collection.gt_mul.len()
        )
        .entered();
        let mut gt_mul_items: Vec<_> = witness_collection.gt_mul.iter().collect();
        gt_mul_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, witness) in gt_mul_items {
            builder.add_gt_mul_witness(witness);
        }
        drop(gt_mul_span);

        // Add G1 scalar mul witnesses
        let g1_scalar_mul_span = tracing::info_span!(
            "add_g1_scalar_mul_witnesses",
            count = witness_collection.g1_scalar_mul.len()
        )
        .entered();
        let mut g1_items: Vec<_> = witness_collection.g1_scalar_mul.iter().collect();
        g1_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, witness) in g1_items {
            builder.add_g1_scalar_mul_witness(witness);
            g1_scalar_mul_public_inputs.push(G1ScalarMulPublicInputs::new(witness.scalar));
        }
        drop(g1_scalar_mul_span);

        // Add G2 scalar mul witnesses
        let g2_scalar_mul_span = tracing::info_span!(
            "add_g2_scalar_mul_witnesses",
            count = witness_collection.g2_scalar_mul.len()
        )
        .entered();
        let mut g2_items: Vec<_> = witness_collection.g2_scalar_mul.iter().collect();
        g2_items.sort_by_key(|(op_id, _)| *op_id);
        for (_op_id, witness) in g2_items {
            builder.add_g2_scalar_mul_witness(witness);
            g2_scalar_mul_public_inputs.push(G2ScalarMulPublicInputs::new(witness.scalar));
        }
        drop(g2_scalar_mul_span);

        // Add G1 add witnesses
        let g1_add_span = tracing::info_span!(
            "add_g1_add_witnesses",
            count = witness_collection.g1_add.len()
        )
        .entered();
        let mut g1_add_items: Vec<_> = witness_collection.g1_add.iter().collect();
        g1_add_items.sort_by_key(|(op_id, _)| *op_id);
        let mut g1_add_witnesses = Vec::with_capacity(g1_add_items.len());
        for (_op_id, witness) in g1_add_items {
            // Convert JoltG1AddWitness (single values) to G1AddWitness<Fq> (constant MLEs)
            // The sumcheck uses 11 variables, so each MLE has 2^11 = 2048 entries
            let mle_size = 1 << 11; // 2048
            let g1_add_constraint = super::stage2::g1_add::G1AddWitness {
                x_p: vec![witness.x_p; mle_size],
                y_p: vec![witness.y_p; mle_size],
                ind_p: vec![witness.ind_p; mle_size],
                x_q: vec![witness.x_q; mle_size],
                y_q: vec![witness.y_q; mle_size],
                ind_q: vec![witness.ind_q; mle_size],
                x_r: vec![witness.x_r; mle_size],
                y_r: vec![witness.y_r; mle_size],
                ind_r: vec![witness.ind_r; mle_size],
                lambda: vec![witness.lambda; mle_size],
                inv_delta_x: vec![witness.inv_delta_x; mle_size],
                is_double: vec![witness.is_double; mle_size],
                is_inverse: vec![witness.is_inverse; mle_size],
                constraint_index: g1_add_witnesses.len(),
            };
            g1_add_witnesses.push(g1_add_constraint);
        }
        drop(g1_add_span);

        // Add G2 add witnesses
        let g2_add_span = tracing::info_span!(
            "add_g2_add_witnesses",
            count = witness_collection.g2_add.len()
        )
        .entered();
        let mut g2_add_items: Vec<_> = witness_collection.g2_add.iter().collect();
        g2_add_items.sort_by_key(|(op_id, _)| *op_id);
        let mut g2_add_witnesses = Vec::with_capacity(g2_add_items.len());
        for (_op_id, witness) in g2_add_items {
            // Convert JoltG2AddWitness (single values) to G2AddWitness<Fq> (constant MLEs)
            let mle_size = 1 << 11;
            let g2_add_constraint = super::stage2::g2_add::G2AddWitness {
                x_p_c0: vec![witness.x_p_c0; mle_size],
                x_p_c1: vec![witness.x_p_c1; mle_size],
                y_p_c0: vec![witness.y_p_c0; mle_size],
                y_p_c1: vec![witness.y_p_c1; mle_size],
                ind_p: vec![witness.ind_p; mle_size],
                x_q_c0: vec![witness.x_q_c0; mle_size],
                x_q_c1: vec![witness.x_q_c1; mle_size],
                y_q_c0: vec![witness.y_q_c0; mle_size],
                y_q_c1: vec![witness.y_q_c1; mle_size],
                ind_q: vec![witness.ind_q; mle_size],
                x_r_c0: vec![witness.x_r_c0; mle_size],
                x_r_c1: vec![witness.x_r_c1; mle_size],
                y_r_c0: vec![witness.y_r_c0; mle_size],
                y_r_c1: vec![witness.y_r_c1; mle_size],
                ind_r: vec![witness.ind_r; mle_size],
                lambda_c0: vec![witness.lambda_c0; mle_size],
                lambda_c1: vec![witness.lambda_c1; mle_size],
                inv_delta_x_c0: vec![witness.inv_delta_x_c0; mle_size],
                inv_delta_x_c1: vec![witness.inv_delta_x_c1; mle_size],
                is_double: vec![witness.is_double; mle_size],
                is_inverse: vec![witness.is_inverse; mle_size],
                constraint_index: g2_add_witnesses.len(),
            };
            g2_add_witnesses.push(g2_add_constraint);
        }
        drop(g2_add_span);

        // Add combine_commitments witnesses (homomorphic combine offloading)
        if let Some(cw) = combine_witness {
            let pre_count = builder.constraint_count();
            tracing::info!(
                "[Homomorphic Combine] Adding {} GT exp + {} GT mul constraints (pre-count: {})",
                cw.exp_witnesses.len(),
                cw.mul_witnesses.len(),
                pre_count
            );

            // Also collect public inputs for the combine witnesses
            for exp_wit in &cw.exp_witnesses {
                gt_exp_public_inputs.push(PackedGtExpPublicInputs::new(
                    exp_wit.base,
                    exp_wit.bits.clone(),
                ));
            }

            let combined_packed_witnesses = builder.add_combine_witness(cw);
            tracing::info!(
                "[Homomorphic Combine] Post-add constraint count: {}, packed witnesses: {}",
                builder.constraint_count(),
                combined_packed_witnesses.len()
            );
            // Add the combined witnesses to our list
            tracing::info!(
                "[Homomorphic Combine] Before extend: {} witnesses, adding {} more",
                gt_exp_witnesses.len(),
                combined_packed_witnesses.len()
            );
            gt_exp_witnesses.extend(combined_packed_witnesses);
        }

        let build_matrix_span = tracing::info_span!("build_matrix").entered();
        let (matrix, constraints) = builder.build();
        drop(build_matrix_span);

        Ok(ConstraintSystem {
            constraints,
            matrix,
            g_poly,
            gt_exp_witnesses,
            gt_exp_public_inputs,
            g1_scalar_mul_public_inputs,
            g2_scalar_mul_public_inputs,
            g1_add_witnesses,
            g2_add_witnesses,
        })
    }
}

impl RecursionProver<Fq> {
    /// Run the full two-stage recursion prover and generate PCS opening proof
    pub fn prove<T: Transcript, PCS: CommitmentScheme<Field = Fq> + RecursionExt<Fq>>(
        self,
        transcript: &mut T,
        prover_setup: &PCS::ProverSetup,
    ) -> Result<RecursionProof<Fq, T, PCS>, Box<dyn std::error::Error>> {
        // Delegate to prove_with_pcs - the RecursionExt trait bound is not actually used
        self.prove_with_pcs(transcript, prover_setup)
    }

    /// Run the full two-stage recursion prover for any PCS (without requiring RecursionExt)
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_with_pcs")]
    pub fn prove_with_pcs<T: Transcript, PCS: CommitmentScheme<Field = Fq>>(
        self,
        transcript: &mut T,
        prover_setup: &PCS::ProverSetup,
    ) -> Result<RecursionProof<Fq, T, PCS>, Box<dyn std::error::Error>> {
        // Initialize opening accumulator
        let log_T = self.constraint_system.num_vars();
        let mut accumulator = ProverOpeningAccumulator::<Fq>::new(log_T);

        // ============ STAGE 1: Constraint Sumchecks ============
        tracing::info_span!("recursion_stage1_sumchecks").in_scope(|| {
            tracing::info!("Starting Stage 1: Constraint sumchecks");
        });
        let (stage1_proof, r_stage1) = self.prove_stage1(transcript, &mut accumulator)?;

        // ============ STAGE 2: Virtualization Sumcheck ============
        tracing::info_span!("recursion_stage2_virtualization").in_scope(|| {
            tracing::info!("Starting Stage 2: Virtualization sumcheck");
        });
        let (stage2_m_eval, r_stage2) =
            self.prove_stage2(transcript, &mut accumulator, &r_stage1)?;

        // ============ STAGE 3: Jagged Transform Sumcheck + Stage 3b: Jagged Assist ============
        tracing::info_span!("recursion_stage3_jagged").in_scope(|| {
            tracing::info!("Starting Stage 3: Jagged transform sumcheck");
        });
        let (stage3_proof, stage3b_proof, _r_stage3) =
            self.prove_stage3(transcript, &mut accumulator, &r_stage1, &r_stage2)?;

        // ============ PCS OPENING PROOF ============
        tracing::info_span!("recursion_pcs_opening_proof").in_scope(|| {
            tracing::info!("Starting PCS opening proof generation");
        });

        // Now we commit to the dense polynomial instead of the full matrix
        let (dense_poly, _bijection, _mapping) = self.constraint_system.build_dense_polynomial();

        // Convert dense polynomial evaluations to F
        let dense_evaluations_f = dense_poly.Z;
        let dense_matrix_poly = MultilinearPolynomial::from(dense_evaluations_f.clone());

        // Commit to the dense polynomial
        let (dense_commitment, _) = PCS::commit(&dense_matrix_poly, prover_setup);

        let mut polynomials_map: HashMap<CommittedPolynomial, MultilinearPolynomial<Fq>> =
            HashMap::new();
        polynomials_map.insert(CommittedPolynomial::DoryDenseMatrix, dense_matrix_poly);

        // Generate opening proof using PCS
        let opening_proof = accumulator
            .prove_single::<T, PCS>(polynomials_map, prover_setup, transcript)
            .map_err(|e| format!("Failed to generate opening proof: {e:?}"))?;

        // Extract opening claims from accumulator
        let opening_claims = accumulator.openings.clone();

        // Create final proof
        let proof = RecursionProof {
            stage1_proof,
            stage2_m_eval,
            stage3_proof,
            stage3b_proof,
            opening_proof,
            gamma: self.gamma,
            delta: self.delta,
            opening_claims,
            dense_commitment,
        };

        Ok(proof)
    }

    /// Run Stage 1: Constraint sumchecks
    #[allow(clippy::type_complexity)]
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage1")]
    pub(crate) fn prove_stage1<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<Fq>,
    ) -> Result<
        (
            crate::subprotocols::sumcheck::SumcheckInstanceProof<Fq, T>,
            Vec<<Fq as JoltField>::Challenge>,
        ),
        Box<dyn std::error::Error>,
    > {
        // Convert g_poly for GT mul (uses zero padding layout: s * 16 + x)
        let g_poly_f = self.constraint_system.g_poly.clone();

        // Create provers for each constraint type
        let mut provers: Vec<Box<dyn SumcheckInstanceProver<Fq, T>>> = Vec::new();

        // Add packed GT exp prover (single prover handles all witnesses with gamma batching)
        let packed_witnesses = &self.constraint_system.gt_exp_witnesses;
        if !packed_witnesses.is_empty() {
            // Packed GT exp uses layout x * 128 + s (s in low bits), so g needs replication
            // Extract 4-var g from the zero-padded version and replicate across s
            let g_4var: Vec<Fq> = self.constraint_system.g_poly.evals()[0..16].to_vec();
            let g_replicated = DoryMatrixBuilder::pad_4var_to_11var_replicated(&g_4var);
            let g_poly_replicated_f = DensePolynomial::new(g_replicated);

            let params = PackedGtExpParams::new();
            tracing::info!(
                "[Stage 1] Creating PackedGtExpProver with {} witnesses",
                packed_witnesses.len()
            );
            let prover =
                PackedGtExpProver::new(params, packed_witnesses, g_poly_replicated_f, transcript);
            provers.push(Box::new(prover));
        }

        // Add GT mul prover if we have GT mul constraints
        let gt_mul_constraints_tuples = self.constraint_system.extract_gt_mul_constraints();
        if !gt_mul_constraints_tuples.is_empty() {
            use super::stage2::gt_mul::GtMulConstraintPolynomials;

            // Use sequential indices (0, 1, 2...) to match Stage 2's expectation.
            // Stage 2's extract_virtual_claims_from_accumulator uses gt_mul_idx which
            // counts sequentially within each constraint type, not global constraint indices.
            let constraint_indices: Vec<usize> = (0..gt_mul_constraints_tuples.len()).collect();

            // Convert tuples to structured type
            let gt_mul_constraints_fq: Vec<GtMulConstraintPolynomials<Fq>> =
                gt_mul_constraints_tuples
                    .into_iter()
                    .map(
                        |(idx, lhs, rhs, result, quotient)| GtMulConstraintPolynomials {
                            lhs,
                            rhs,
                            result,
                            quotient,
                            constraint_index: idx,
                        },
                    )
                    .collect();

            let params = GtMulParams::new(gt_mul_constraints_fq.len());

            let gt_mul_constraints_f = gt_mul_constraints_fq;

            let spec = GtMulProverSpec::new(params, gt_mul_constraints_f, g_poly_f.clone());
            let prover = GtMulProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // Add G1 scalar mul prover if we have G1 scalar mul constraints
        let g1_scalar_mul_constraints_tuples =
            self.constraint_system.extract_g1_scalar_mul_constraints();
        if !g1_scalar_mul_constraints_tuples.is_empty() {
            use super::stage2::g1_scalar_mul::{
                G1ScalarMulConstraintPolynomials, G1ScalarMulParams, G1ScalarMulProver,
                G1ScalarMulProverSpec,
            };

            debug_assert_eq!(
                self.constraint_system.g1_scalar_mul_public_inputs.len(),
                g1_scalar_mul_constraints_tuples.len(),
                "ConstraintSystem.g1_scalar_mul_public_inputs must match extracted G1 scalar-mul constraints"
            );

            // Convert witness structs to constraint polynomials and base_points
            let mut g1_scalar_mul_constraints: Vec<G1ScalarMulConstraintPolynomials<Fq>> =
                Vec::with_capacity(g1_scalar_mul_constraints_tuples.len());
            let mut g1_scalar_mul_base_points: Vec<(Fq, Fq)> =
                Vec::with_capacity(g1_scalar_mul_constraints_tuples.len());

            for w in g1_scalar_mul_constraints_tuples {
                g1_scalar_mul_constraints.push(G1ScalarMulConstraintPolynomials {
                    x_a: w.x_a,
                    y_a: w.y_a,
                    x_t: w.x_t,
                    y_t: w.y_t,
                    x_a_next: w.x_a_next,
                    y_a_next: w.y_a_next,
                    t_indicator: w.t_indicator,
                    a_indicator: w.a_indicator,
                    constraint_index: w.constraint_index,
                });
                g1_scalar_mul_base_points.push(w.base_point);
            }

            let params = G1ScalarMulParams::new(g1_scalar_mul_constraints.len());
            let (spec, constraint_indices) = G1ScalarMulProverSpec::new(
                params,
                g1_scalar_mul_constraints,
                &self.constraint_system.g1_scalar_mul_public_inputs,
                g1_scalar_mul_base_points,
            );
            let prover = G1ScalarMulProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // Add G2 scalar mul prover if we have G2 scalar mul constraints
        let g2_scalar_mul_constraints_tuples =
            self.constraint_system.extract_g2_scalar_mul_constraints();
        if !g2_scalar_mul_constraints_tuples.is_empty() {
            use super::stage2::g2_scalar_mul::{
                G2ScalarMulConstraintPolynomials, G2ScalarMulParams, G2ScalarMulProver,
                G2ScalarMulProverSpec,
            };

            debug_assert_eq!(
                self.constraint_system.g2_scalar_mul_public_inputs.len(),
                g2_scalar_mul_constraints_tuples.len(),
                "ConstraintSystem.g2_scalar_mul_public_inputs must match extracted G2 scalar-mul constraints"
            );

            // Convert witness structs to constraint polynomials and base_points
            let mut g2_scalar_mul_constraints: Vec<G2ScalarMulConstraintPolynomials<Fq>> =
                Vec::with_capacity(g2_scalar_mul_constraints_tuples.len());
            let mut g2_scalar_mul_base_points =
                Vec::with_capacity(g2_scalar_mul_constraints_tuples.len());

            for w in g2_scalar_mul_constraints_tuples {
                g2_scalar_mul_constraints.push(G2ScalarMulConstraintPolynomials {
                    x_a_c0: w.x_a_c0,
                    x_a_c1: w.x_a_c1,
                    y_a_c0: w.y_a_c0,
                    y_a_c1: w.y_a_c1,
                    x_t_c0: w.x_t_c0,
                    x_t_c1: w.x_t_c1,
                    y_t_c0: w.y_t_c0,
                    y_t_c1: w.y_t_c1,
                    x_a_next_c0: w.x_a_next_c0,
                    x_a_next_c1: w.x_a_next_c1,
                    y_a_next_c0: w.y_a_next_c0,
                    y_a_next_c1: w.y_a_next_c1,
                    t_indicator: w.t_indicator,
                    a_indicator: w.a_indicator,
                    constraint_index: w.constraint_index,
                });
                g2_scalar_mul_base_points.push(w.base_point);
            }

            let params = G2ScalarMulParams::new(g2_scalar_mul_constraints.len());
            let (spec, constraint_indices) = G2ScalarMulProverSpec::new(
                params,
                g2_scalar_mul_constraints,
                &self.constraint_system.g2_scalar_mul_public_inputs,
                g2_scalar_mul_base_points,
            );
            let prover = G2ScalarMulProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // Add G1 add prover
        let g1_add_constraints = self.constraint_system.extract_g1_add_constraints();
        if !g1_add_constraints.is_empty() {
            use super::stage2::g1_add::{G1AddParams, G1AddProver, G1AddProverSpec};

            // G1AddWitness<Fq> = G1AddConstraintPolynomials<Fq> via type alias, no conversion needed
            let params = G1AddParams::new(g1_add_constraints.len());
            let (spec, constraint_indices) = G1AddProverSpec::new(params, g1_add_constraints);
            let prover = G1AddProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // Add G2 add prover
        let g2_add_constraints = self.constraint_system.extract_g2_add_constraints();
        if !g2_add_constraints.is_empty() {
            use super::stage2::g2_add::{G2AddParams, G2AddProver, G2AddProverSpec};

            // G2AddWitness<Fq> = G2AddConstraintPolynomials<Fq> via type alias, no conversion needed
            let params = G2AddParams::new(g2_add_constraints.len());
            let (spec, constraint_indices) = G2AddProverSpec::new(params, g2_add_constraints);
            let prover = G2AddProver::from_spec(spec, constraint_indices, transcript);
            provers.push(Box::new(prover));
        }

        // Add Multi-Miller loop prover
        // Note: We need to extract multi-miller loop witnesses from the constraint system
        // But I haven't added them to ConstraintSystem yet.
        // I need to update ConstraintSystem first.
        // For now, I'll skip adding the prover if no witnesses are present (which is true).

        // TODO: Add Boundary/Wiring Sumcheck (initial/final states + copy constraints)
        // Currently removed due to polynomial size mismatch bug; will be redesigned with packing.

        if provers.is_empty() {
            return Err("No constraints to prove in Stage 1".into());
        }

        // Run batched sumcheck for all provers
        let (proof, r_stage1) = BatchedSumcheck::prove(
            provers.iter_mut().map(|p| &mut **p as _).collect(),
            accumulator,
            transcript,
        );

        Ok((proof, r_stage1))
    }

    /// Run Stage 2: Direct evaluation protocol
    #[allow(clippy::type_complexity)]
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage2")]
    pub(crate) fn prove_stage2<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<Fq>,
        r_stage1: &[<Fq as JoltField>::Challenge],
    ) -> Result<
        (
            Fq, // Return m_eval instead of sumcheck proof
            Vec<<Fq as JoltField>::Challenge>,
        ),
        Box<dyn std::error::Error>,
    > {
        // Since we know F = Fq, we can work directly with Fq types
        let accumulator_fq: &mut ProverOpeningAccumulator<Fq> = accumulator;

        // Convert r_stage1 challenges to Fq field elements
        // SAFETY: We verified F = Fq above, so F::Challenge = Fq::Challenge
        let r_x: Vec<Fq> = r_stage1.iter().map(|c| (*c).into()).collect();

        // Extract virtual claims from Stage 1
        let constraint_types: Vec<ConstraintType> = self
            .constraint_system
            .constraints
            .iter()
            .map(|c| c.constraint_type.clone())
            .collect();
        let virtual_claims = extract_virtual_claims_from_accumulator(
            accumulator_fq,
            &constraint_types,
            &self.constraint_system.gt_exp_public_inputs,
        );

        // Create parameters
        let params = DirectEvaluationParams::new(
            self.constraint_system.num_s_vars(),
            self.constraint_system.num_constraints(),
            self.constraint_system.matrix.num_constraints_padded,
            self.constraint_system.matrix.num_constraint_vars,
        );

        // Create and run prover
        let prover = DirectEvaluationProver::new(
            params,
            self.constraint_system.matrix.evaluations.clone(),
            virtual_claims,
            r_x.clone(),
        );

        let (r_s, m_eval) = prover.prove(transcript, accumulator_fq);

        // Convert r_s to challenges for Stage 3 compatibility
        // Stage 3 expects them in reverse order
        let r_stage2: Vec<<Fq as JoltField>::Challenge> =
            r_s.into_iter().rev().map(|f| f.into()).collect();

        Ok((m_eval, r_stage2))
    }

    /// Run Stage 3: Jagged Transform Sumcheck + Stage 3b: Jagged Assist
    #[allow(clippy::type_complexity)]
    #[tracing::instrument(skip_all, name = "RecursionProver::prove_stage3")]
    pub(crate) fn prove_stage3<T: Transcript>(
        &self,
        transcript: &mut T,
        accumulator: &mut ProverOpeningAccumulator<Fq>,
        r_stage1: &[<Fq as JoltField>::Challenge],
        r_stage2: &[<Fq as JoltField>::Challenge],
    ) -> Result<
        (
            crate::subprotocols::sumcheck::SumcheckInstanceProof<Fq, T>,
            JaggedAssistProof<Fq, T>,
            Vec<<Fq as JoltField>::Challenge>,
        ),
        Box<dyn std::error::Error>,
    > {
        // Get the opening claim from Stage 2 using explicit key lookup (not .last() which depends on insertion order)
        let (_, sparse_claim_value) = accumulator.get_virtual_polynomial_opening(
            VirtualPolynomial::DorySparseConstraintMatrix,
            SumcheckId::RecursionVirtualization,
        );

        // Build dense polynomial, bijection, and mapping
        let (dense_poly_fq, bijection, mapping) = self.constraint_system.build_dense_polynomial();

        // Convert dense polynomial from Fq to F (safe because F = Fq in recursion)
        let dense_poly_f = dense_poly_fq;

        // Convert r_stage2 (s challenges) and r_stage1 (x challenges) to F
        let r_s_final: Vec<Fq> = r_stage2.iter().map(|c| (*c).into()).collect();
        let r_x_prev: Vec<Fq> = r_stage1.iter().map(|c| (*c).into()).collect();

        // Precompute matrix row indices for all polynomial indices
        let num_polynomials = bijection.num_polynomials();
        let mut matrix_rows = Vec::with_capacity(num_polynomials);
        for poly_idx in 0..num_polynomials {
            let (constraint_idx, poly_type) = mapping.decode(poly_idx);
            let matrix_row = self
                .constraint_system
                .matrix
                .row_index(poly_type, constraint_idx);
            matrix_rows.push(matrix_row);
        }

        // Create Stage 3 prover
        let mut jagged_prover = JaggedSumcheckProver::new(
            (r_s_final.clone(), r_x_prev.clone()),
            sparse_claim_value,
            dense_poly_f,
            bijection.clone(),
            mapping,
            matrix_rows.clone(),
            transcript,
            self.constraint_system.num_s_vars(),
            self.constraint_system.matrix.num_constraint_vars,
        );

        // Run the jagged sumcheck using BatchedSumcheck
        let (stage3_proof, r_stage3) =
            BatchedSumcheck::prove(vec![&mut jagged_prover], accumulator, transcript);

        // ============ STAGE 3b: Jagged Assist (Batch MLE Verification) ============
        tracing::info_span!("recursion_stage3b_jagged_assist").in_scope(|| {
            tracing::info!("Starting Stage 3b: Jagged Assist batch MLE verification");
        });

        // Convert r_stage3 (dense challenges) to F
        let r_dense: Vec<Fq> = r_stage3.iter().map(|c| (*c).into()).collect();

        // Compute num_bits for branching program
        let num_constraint_vars = self.constraint_system.matrix.num_constraint_vars;
        let dense_size = <super::bijection::VarCountJaggedBijection as super::bijection::JaggedTransform<Fq>>::dense_size(&bijection);
        let num_dense_vars = dense_size.next_power_of_two().trailing_zeros() as usize;
        let num_bits = std::cmp::max(num_constraint_vars, num_dense_vars);

        // Create Jagged Assist prover - iterates over K polynomials (not rows!)
        let mut assist_prover =
            JaggedAssistProver::<Fq, T>::new(r_x_prev, r_dense, &bijection, num_bits, transcript);

        // Run Jagged Assist sumcheck
        let (stage3b_sumcheck_proof, _r_assist) =
            BatchedSumcheck::prove(vec![&mut assist_prover], accumulator, transcript);

        // Create the JaggedAssistProof
        let stage3b_proof = JaggedAssistProof {
            claimed_evaluations: assist_prover.claimed_evaluations.clone(),
            sumcheck_proof: stage3b_sumcheck_proof,
        };

        Ok((stage3_proof, stage3b_proof, r_stage3))
    }
}
